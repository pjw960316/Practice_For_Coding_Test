# 목차
- [목차](#목차)
- [그래프는 BFS를 사용하자.](#그래프는-bfs를-사용하자)
- [BFS의 배열은 1,1부터 수행하는 것이 좋다.](#bfs의-배열은-11부터-수행하는-것이-좋다)
- [x,y 대신 r,c를 사용한다. 그리고 r과 c에 대해서 명확히 검증을 하고 이용한다.](#xy-대신-rc를-사용한다-그리고-r과-c에-대해서-명확히-검증을-하고-이용한다)
- [캐싱으로 가독성 향상.](#캐싱으로-가독성-향상)
- [실수하는 것 들](#실수하는-것-들)
    - [1. pop의 타이밍](#1-pop의-타이밍)
    - [2. queue의 front()](#2-queue의-front)

# 그래프는 BFS를 사용하자.
- 아직까지 코딩테스트 수준에서 반드시 DFS를 사용해야 하는 그래프 문제를 발견하지 못했다.
- 뭘 사용할 지 고민하는 것 보다 확실한 방법으로 문제에 접근하는 것이 중요하다.
  - 세계 올림피아드 대회가 아니니까.

# BFS의 배열은 1,1부터 수행하는 것이 좋다.
- 4방향, 8방향을 탐색하는 과정에서 0,0부터 한다면 -1,-1에 접근하게 되는데 이를 방지하기 위해 안전하게 1,1 ~ r,c로 구현하는 것이 간편하다.

# x,y 대신 r,c를 사용한다. 그리고 r과 c에 대해서 명확히 검증을 하고 이용한다.
- Row와 Column은 헷갈릴 수 가 없다.
- 요즘 문제들은 row와 column을 꼬아서 출제한다. **문제 다 풀고 해당 실수를 발견하면 멘탈이 나간다.**
  - 반드시 r과 c에 데이터를 넣을 때 검증 또 검증.

# 캐싱으로 가독성 향상.
- 좌표를 나타낼 때 코드가 복잡해지므로 캐싱을 하여 가독성을 높인다.
~~~c++
int cur_r=0, cur_c=0;
cur_r = q.front().r + path[i].first;
cur_c = q.front().c + path[i].second;

if(arr[cur_r][cur_c] == 0)
{
    cout << "캐싱이 좋아";
} 
~~~

# 실수하는 것 들
### 1. pop의 타이밍
- queue의 원소에 대해서 4방향, 8방향을 수행하고 queue의 front원소를 pop 해준다.
- 간혹 4방향을 검사할 때 마다 pop을 해서 queue 관련 에러가 발생한다.
### 2. queue의 front()
- queue의 front()는 결국 현재 queue의 첫 번째 값을 나타내기 때문에 올바른 시점에서 front() 값을 참고하는지 확인한다.
 
