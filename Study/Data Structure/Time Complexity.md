# 목차
- [목차](#목차)
- [개요](#개요)
- [코딩테스트의 시간복잡도](#코딩테스트의-시간복잡도)
- [유추하기 위한 몇 가지 수](#유추하기-위한-몇-가지-수)
- [:star:시간복잡도에 대한 검증](#star시간복잡도에-대한-검증)
    - [1. clear](#1-clear)
    - [2. 복사 (v2=v1)](#2-복사-v2v1)

# 개요
- 실무에서 정말 중요하다.
- 많은 버그와 개선점에는 최적화가 있고, 자료구조를 이용하면 최적화를 할 수 있는 부분이 정말 많다.

# 코딩테스트의 시간복잡도
- 시간복잡도가 터진다 = 더 빠른 자료구조를 이용해서 문제를 다시 풀어야 한다.
- 문제의 난이도를 증가시킨다.
- **:star:시간복잡도를 설계 단계에서 유추할 수 있어야 한다!**

# 유추하기 위한 몇 가지 수
- 숫자를 기억하면 편하다.
- :link:[계산기](http://mwultong.blogspot.com/2008/01/2-log-calc.html)
- log1000 = 10
- log10^6 = log(1000 * 1000) = log1000 + log1000 = 10 + 10 = 20 

# :star:시간복잡도에 대한 검증
### 1. clear
- 자료구조의 clear는 o(n)이다.
- n이 크다면 다시 선언해버리는 것도 나쁘지 않다.
-  :heavy_exclamation_mark: 테스트를 해보면 빠르게(거의 O(1)) 나온다.
  - 일단은 문제가 없을 때 까지 clear를 사용하자.


### 2. 복사 (v2=v1)
- o(n)이다.
~~~c++
for(int i=0; i<123123123; i++)
{
    v.push_back(i);
}
v2 = v; //198 ms
~~~
  - 이전에는 o(1)이라고 생각했다.
  - 그건 포인터 개념으로 생각했을 때 이다.
    - 하지만 포인터를 생각하면 복사가 아니라 메모리에 접근을 추가로 하는 것이므로 원본 값이 변경되어 예기치 못한 문제가 발생한다.
    - :star:큰 자료구조를 반복문에서 복사한다면 이는 시간복잡도를 많이 증가시킬 것 이다.